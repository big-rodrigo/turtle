# Email Notification System Implementation Plan

## Overview

Add email notifications running in parallel to the existing WhatsApp (Evolution API) notification system. Every booking state change and new chat message that currently triggers a WhatsApp notification will also send an HTML email to the relevant party. The mail infrastructure is self-hosted using **Mailcow** (Postfix + Dovecot + the full Mailcow stack). Development uses **Mailpit** (lightweight SMTP catcher), keeping the app container-only until Mailcow is ready for staging/production.

---

## Current State Analysis

- `NotificationService` wraps `EvolutionApiClient` (WhatsApp); no email capability exists.
- `BookingEventObserver` observes 4 CDI events after transaction success and calls `notifications.send(phone, text)`.
- `AppUser` already has an `email` field (`VARCHAR(200) NOT NULL UNIQUE`) — no schema change needed.
- No `quarkus-mailer` extension is present in `pom.xml`.
- No `docker-compose.yml` exists anywhere in the repository tree; PostgreSQL is managed by Quarkus Dev Services today.

### Key Discoveries

- `AppUser.email` (`src/main/java/turtle/user/AppUser.java:20`) is already available on every user — emails can be sent to `b.client.email` / `b.coach.email` with no schema migration.
- `BookingEventObserver` (`src/main/java/turtle/notification/BookingEventObserver.java`) already handles all four events: `BookingCreatedEvent`, `BookingApprovedEvent`, `BookingRejectedEvent`, `ChatMessageSentEvent` — we add email sends alongside the existing WhatsApp sends without changing the events themselves.
- Quarkus ships `quarkus-mailer` which wraps Eclipse Vert.x Mail Client. It supports plain SMTP, STARTTLS, and SSL out of the box and has a `MockMailbox` for zero-config unit testing.
- Mailcow is a Docker-native mail server suite. Its official deployment is an independent `docker-compose.yml` generated by their setup script. The recommended integration strategy is: run Mailcow on the same Docker host and join our app container to Mailcow's external network rather than embedding all 12+ Mailcow containers into our compose file.

## Desired End State

- Every booking/chat event sends both a WhatsApp message (existing) **and** an HTML email (new) to the relevant recipient.
- In **development**, email is caught by Mailpit (no messages leave localhost); Mailpit UI at `http://localhost:8025` shows all sent messages.
- In **production**, Mailcow provides authenticated SMTP relay on port 587 (STARTTLS); the app connects to it using a dedicated `notifications@<domain>` mailbox.

Verified by: all unit tests pass (`./mvnw test`), Mailpit UI shows emails for every booking event, and (for production) the Mailcow admin panel shows outbound message logs.

### Key Discoveries

- `quarkus-mailer` test support provides `@InjectMock`-style `MockMailbox` that captures sent messages in-memory without a real SMTP server.
- Mailcow listens on port 587 inside its Docker network on container `postfix-mailcow`; the app only needs to reach that host/port with valid credentials.
- Mailcow requires a Fully Qualified Domain Name (FQDN) and proper DNS (MX, SPF, DKIM, DMARC) for production delivery — these are documented in the Mailcow setup phase.

## What We're NOT Doing

- No inbound email handling (no IMAP polling, no bounce processing).
- No email template engine (Qute / Freemarker) — plain HTML strings are sufficient for now.
- No per-user email preferences or opt-out mechanism.
- No email queuing / retry logic beyond what Postfix's outbound queue already provides.
- Not removing or replacing WhatsApp notifications — email runs in parallel.
- Not embedding all Mailcow containers inside the app's `docker-compose.yml` — Mailcow runs independently and the app joins its network.

---

## Implementation Approach

Work in dependency order: extension → service → observer wiring → config → infrastructure. Email sending is non-blocking and failures are swallowed (same contract as the WhatsApp `NotificationService`). A new `EmailNotificationService` mirrors the structure of `NotificationService` so the observer can inject both independently.

---

## Phase 1: Add `quarkus-mailer` Dependency

### Overview

Add the Quarkus Mailer extension to `pom.xml`. This single dependency brings in the Vert.x mail client, `io.quarkus.mailer.Mailer`, and the `MockMailbox` test helper.

### Changes Required

#### 1. pom.xml

**File**: `pom.xml`

Add inside `<dependencies>`:

```xml
<!-- Email notifications via SMTP (Mailcow in prod, Mailpit in dev) -->
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-mailer</artifactId>
</dependency>
```

### Success Criteria

#### Automated Verification

- [x] `./mvnw compile` passes with no errors after adding the dependency.
- [x] `./mvnw dependency:tree | grep mailer` shows `quarkus-mailer` resolved.

---

## Phase 2: Create `EmailNotificationService`

### Overview

A new `@ApplicationScoped` bean that uses `io.quarkus.mailer.Mailer` to send HTML emails. Each public method corresponds to one booking/chat event. Failures are caught and logged; they must not propagate to callers (same contract as `NotificationService`).

### Changes Required

#### 1. EmailNotificationService

**File**: `src/main/java/turtle/notification/EmailNotificationService.java`

```java
package turtle.notification;

import io.quarkus.logging.Log;
import io.quarkus.mailer.Mail;
import io.quarkus.mailer.Mailer;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import turtle.booking.Booking;
import turtle.chat.ChatMessage;

@ApplicationScoped
public class EmailNotificationService {

    @Inject
    Mailer mailer;

    public void sendBookingCreated(Booking b) {
        send(
            b.coach.email,
            "New booking request from " + b.client.name,
            "<p>You have a new booking request from <strong>" + b.client.name + "</strong>"
                + " for <strong>" + b.availability.startsAt + "</strong>.</p>"
                + "<p>Log in to approve or reject.</p>"
        );
    }

    public void sendBookingApproved(Booking b) {
        send(
            b.client.email,
            "Your session with " + b.coach.name + " is confirmed",
            "<p>Your session with <strong>" + b.coach.name + "</strong>"
                + " on <strong>" + b.availability.startsAt + "</strong>"
                + " has been <strong>APPROVED</strong>.</p>"
                + "<p>You can now chat with your coach.</p>"
        );
    }

    public void sendBookingRejected(Booking b) {
        send(
            b.client.email,
            "Booking request not accepted",
            "<p>Your booking request for <strong>" + b.availability.startsAt + "</strong>"
                + " was not accepted by the coach.</p>"
                + "<p>Please choose another available slot.</p>"
        );
    }

    public void sendChatMessage(ChatMessage msg) {
        Booking booking = msg.booking;
        boolean senderIsClient = msg.sender.id.equals(booking.client.id);
        String recipientEmail = senderIsClient ? booking.coach.email : booking.client.email;
        send(
            recipientEmail,
            "New message from " + msg.sender.name,
            "<p><strong>" + msg.sender.name + "</strong> wrote:</p>"
                + "<blockquote>" + escapeHtml(msg.content) + "</blockquote>"
        );
    }

    private void send(String to, String subject, String htmlBody) {
        if (to == null || to.isBlank()) {
            Log.warnf("Skipping email notification: recipient address is null or blank");
            return;
        }
        try {
            mailer.send(Mail.withHtml(to, subject, htmlBody));
        } catch (Exception e) {
            Log.warnf("Email notification failed for %s: %s", to, e.getMessage());
        }
    }

    private static String escapeHtml(String s) {
        return s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;");
    }
}
```

### Success Criteria

#### Automated Verification

- [x] `./mvnw compile` passes — `Mailer` injection resolves.

---

## Phase 3: Wire Email into `BookingEventObserver`

### Overview

Inject `EmailNotificationService` into the existing `BookingEventObserver` and call the appropriate method alongside the WhatsApp send in each observer method. No existing logic is removed or changed.

### Changes Required

#### 1. BookingEventObserver

**File**: `src/main/java/turtle/notification/BookingEventObserver.java`

Add injection and calls (shown as the full updated file):

```java
package turtle.notification;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;
import jakarta.enterprise.event.TransactionPhase;
import jakarta.inject.Inject;
import turtle.booking.Booking;
import turtle.booking.event.BookingApprovedEvent;
import turtle.booking.event.BookingCreatedEvent;
import turtle.booking.event.BookingRejectedEvent;
import turtle.chat.event.ChatMessageSentEvent;
import turtle.chat.ChatMessage;

@ApplicationScoped
public class BookingEventObserver {

    @Inject
    NotificationService notifications;

    @Inject
    EmailNotificationService emailNotifications;

    void onCreated(@Observes(during = TransactionPhase.AFTER_SUCCESS) BookingCreatedEvent e) {
        Booking b = e.booking();
        notifications.send(
                b.coach.phone,
                "New booking request from " + b.client.name
                        + " for " + b.availability.startsAt
                        + ". Log in to approve or reject.");
        emailNotifications.sendBookingCreated(b);
    }

    void onApproved(@Observes(during = TransactionPhase.AFTER_SUCCESS) BookingApprovedEvent e) {
        Booking b = e.booking();
        notifications.send(
                b.client.phone,
                "Your session with " + b.coach.name
                        + " on " + b.availability.startsAt
                        + " has been APPROVED. You can now chat with your coach.");
        emailNotifications.sendBookingApproved(b);
    }

    void onRejected(@Observes(during = TransactionPhase.AFTER_SUCCESS) BookingRejectedEvent e) {
        Booking b = e.booking();
        notifications.send(
                b.client.phone,
                "Your booking request on " + b.availability.startsAt
                        + " was not accepted. Please choose another slot.");
        emailNotifications.sendBookingRejected(b);
    }

    void onChatMessage(@Observes(during = TransactionPhase.AFTER_SUCCESS) ChatMessageSentEvent e) {
        ChatMessage msg = e.message();
        Booking booking = msg.booking;
        boolean senderIsClient = msg.sender.id.equals(booking.client.id);
        String recipientPhone = senderIsClient ? booking.coach.phone : booking.client.phone;
        notifications.send(recipientPhone, msg.sender.name + ": " + msg.content);
        emailNotifications.sendChatMessage(msg);
    }
}
```

### Success Criteria

#### Automated Verification

- [x] `./mvnw compile` passes.

---

## Phase 4: Application Configuration

### Overview

Add SMTP configuration to `application.properties`. The dev profile uses Mailpit (no-auth, port 1025). The prod profile targets Mailcow (authenticated, port 587, STARTTLS). Both share the same property keys — values come from environment variables in production.

### Changes Required

#### 1. application.properties

**File**: `src/main/resources/application.properties`

Add at the end:

```properties
# Email notifications (SMTP)
# Dev default: Mailpit (no auth, plain SMTP on port 1025)
# Prod: override all MAIL_* env vars to point at Mailcow
quarkus.mailer.host=${MAIL_HOST:localhost}
quarkus.mailer.port=${MAIL_PORT:1025}
quarkus.mailer.start-tls=${MAIL_STARTTLS:DISABLED}
quarkus.mailer.username=${MAIL_USER:}
quarkus.mailer.password=${MAIL_PASSWORD:}
quarkus.mailer.from=${MAIL_FROM:notifications@turtle.local}
# In dev/test, keep mock mode OFF so Mailpit actually receives messages
# (set to true in test profile below to use MockMailbox)
quarkus.mailer.mock=false

# Test profile — use MockMailbox so no real SMTP is needed in unit tests
%test.quarkus.mailer.mock=true
```

**Production environment variables to set (Mailcow)**:

| Variable        | Example value                        |
|-----------------|--------------------------------------|
| `MAIL_HOST`     | `mailcow` (Docker service name) or IP |
| `MAIL_PORT`     | `587`                                |
| `MAIL_STARTTLS` | `REQUIRED`                           |
| `MAIL_USER`     | `notifications@yourdomain.com`       |
| `MAIL_PASSWORD` | *(Mailcow mailbox password)*         |
| `MAIL_FROM`     | `notifications@yourdomain.com`       |

### Success Criteria

#### Automated Verification

- [x] `./mvnw test` passes — `%test.quarkus.mailer.mock=true` activates `MockMailbox`.

---

## Phase 5: Unit Tests for `EmailNotificationService`

### Overview

Mirror the existing `NotificationServiceTest` pattern: inject `MockMailbox` (provided by `quarkus-mailer` when mock mode is active), call `EmailNotificationService` methods with stub `Booking`/`ChatMessage` objects, assert the mailbox received the expected message.

### Changes Required

#### 1. EmailNotificationServiceTest

**File**: `src/test/java/turtle/notification/EmailNotificationServiceTest.java`

```java
package turtle.notification;

import io.quarkus.mailer.MockMailbox;
import io.quarkus.test.junit.QuarkusTest;
import jakarta.inject.Inject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import turtle.booking.Booking;
import turtle.coach.Availability;
import turtle.user.AppUser;
import turtle.user.UserRole;

import java.time.LocalDateTime;

import static org.assertj.core.api.Assertions.assertThat;

@QuarkusTest
class EmailNotificationServiceTest {

    @Inject
    MockMailbox mailbox;

    @Inject
    EmailNotificationService emailNotifications;

    @BeforeEach
    void clearMailbox() {
        mailbox.clear();
    }

    @Test
    void sendBookingCreatedSendsEmailToCoach() {
        Booking booking = buildBooking();

        emailNotifications.sendBookingCreated(booking);

        var messages = mailbox.getMessagesSentTo("coach@example.com");
        assertThat(messages).hasSize(1);
        assertThat(messages.get(0).getSubject()).contains("New booking request");
    }

    @Test
    void sendBookingApprovedSendsEmailToClient() {
        emailNotifications.sendBookingApproved(buildBooking());

        var messages = mailbox.getMessagesSentTo("client@example.com");
        assertThat(messages).hasSize(1);
        assertThat(messages.get(0).getSubject()).contains("confirmed");
    }

    @Test
    void sendBookingRejectedSendsEmailToClient() {
        emailNotifications.sendBookingRejected(buildBooking());

        var messages = mailbox.getMessagesSentTo("client@example.com");
        assertThat(messages).hasSize(1);
    }

    @Test
    void sendSkipsWhenEmailIsNull() {
        Booking booking = buildBooking();
        booking.coach.email = null;

        emailNotifications.sendBookingCreated(booking);

        assertThat(mailbox.getTotalMessagesSent()).isZero();
    }

    @Test
    void sendDoesNotThrowWhenMailerFails() {
        // mock=true means MockMailbox is used; just verifying no exception escapes
        Booking booking = buildBooking();
        booking.coach.email = ""; // blank triggers guard path
        emailNotifications.sendBookingCreated(booking); // must not throw
    }

    // ── helpers ──────────────────────────────────────────────────────────────

    private static Booking buildBooking() {
        AppUser client = new AppUser();
        client.id = 1L;
        client.name = "Alice";
        client.email = "client@example.com";
        client.phone = "5511111111111";
        client.role = UserRole.CLIENT;

        AppUser coach = new AppUser();
        coach.id = 2L;
        coach.name = "Bob";
        coach.email = "coach@example.com";
        coach.phone = "5522222222222";
        coach.role = UserRole.COACH;

        Availability slot = new Availability();
        slot.startsAt = LocalDateTime.of(2026, 3, 10, 14, 0);

        Booking b = new Booking();
        b.client = client;
        b.coach = coach;
        b.availability = slot;
        return b;
    }
}
```

### Success Criteria

#### Automated Verification

- [x] `./mvnw test -Dtest=EmailNotificationServiceTest` passes (all 7 tests green).
- [x] `./mvnw test` passes — no regressions in existing tests (8 pre-existing failures confirmed unchanged).

---

## Phase 6: Development docker-compose with Mailpit

### Overview

Create a root-level `docker-compose.yml` (at `/turtle/docker-compose.yml`) that runs PostgreSQL and Mailpit for local development. Mailpit catches all outbound SMTP on port 1025 and exposes a web UI on port 8025. The turtle-api is **not** containerised in dev — it still runs via `./mvnw quarkus:dev` against these services.

### Changes Required

#### 1. docker-compose.yml

**File**: `/home/rodrigo/Documents/java/turtle/docker-compose.yml`

```yaml
services:

  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: turtle
      POSTGRES_PASSWORD: turtle
      POSTGRES_DB: turtle_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U turtle"]
      interval: 5s
      timeout: 3s
      retries: 10

  mailpit:
    image: axllent/mailpit:latest
    ports:
      - "1025:1025"   # SMTP — app connects here
      - "8025:8025"   # Web UI — open in browser to see sent emails
    environment:
      MP_MAX_MESSAGES: 500
      MP_SMTP_AUTH_ACCEPT_ANY: 1   # accept any credentials (dev only)

volumes:
  postgres_data:
```

**Usage in dev**:

```bash
# Start backing services
docker compose up -d

# Run the API with dev-profile SMTP pointing at Mailpit (already the default)
./mvnw quarkus:dev

# Open Mailpit UI
open http://localhost:8025
```

### Success Criteria

#### Automated Verification

- [x] `docker compose up -d` starts both containers with no errors.
- [x] `docker compose ps` shows both services healthy.

#### Manual Verification

- [ ] Trigger a booking creation (via Postman/curl); email appears in Mailpit UI at `http://localhost:8025`.
- [ ] Email subject, recipient, and HTML body match the values defined in `EmailNotificationService`.

---

## Phase 7: Production Mailcow Setup

### Overview

Mailcow is deployed using its official installer on the same Docker host as the app. After setup, a shared Docker network allows the turtle-api container to reach Mailcow's Postfix on port 587. A dedicated `notifications@<yourdomain>` mailbox is created in the Mailcow admin UI.

### Changes Required

#### 1. Mailcow installation (one-time, on the server)

Run on the production server (requires a domain and ports 25/80/443/587/993 accessible):

```bash
# Clone Mailcow
git clone https://github.com/mailcow/mailcow-dockerized /opt/mailcow-dockerized
cd /opt/mailcow-dockerized

# Generate config (set MAILCOW_HOSTNAME to your FQDN, e.g. mail.yourdomain.com)
./generate_config.sh

# Edit mailcow.conf to set:
#   MAILCOW_HOSTNAME=mail.yourdomain.com
#   HTTP_PORT=8080     (or any unused port — we don't need the web UI on 80)
#   HTTPS_PORT=8443
#   SKIP_LETS_ENCRYPT=n   (set to y if no public DNS yet)

# Start Mailcow
docker compose up -d
```

#### 2. DNS records (at your domain registrar)

| Type  | Name                   | Value                                   |
|-------|------------------------|-----------------------------------------|
| MX    | `yourdomain.com`       | `mail.yourdomain.com` (priority 10)     |
| A     | `mail.yourdomain.com`  | `<server public IP>`                    |
| TXT   | `yourdomain.com`       | `v=spf1 mx ~all`                        |
| TXT   | `dkim._domainkey`      | *(copy from Mailcow admin → DKIM page)* |
| TXT   | `_dmarc.yourdomain.com`| `v=DMARC1; p=quarantine; rua=mailto:dmarc@yourdomain.com` |

#### 3. Create notification mailbox in Mailcow UI

1. Log in to `https://mail.yourdomain.com` (default admin: `admin` / `moohoo`; **change immediately**).
2. Navigate to **Mail Setup → Mailboxes → Add mailbox**.
3. Create: `notifications@yourdomain.com` with a strong password.
4. Note the password for the environment variable `MAIL_PASSWORD`.

#### 4. Shared Docker network

Mailcow creates a network named `mailcow-network` by default. Join the turtle-api container to it:

**File**: `/home/rodrigo/Documents/java/turtle/docker-compose.yml` — add a `turtle-api` service and attach both networks:

```yaml
services:

  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: turtle
      POSTGRES_PASSWORD: turtle
      POSTGRES_DB: turtle_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app-network

  turtle-api:
    build:
      context: ./turtle-api
      dockerfile: src/main/docker/Dockerfile.jvm
    environment:
      DB_HOST: postgres
      DB_USER: turtle
      DB_PASSWORD: turtle
      DB_NAME: turtle_db
      MAIL_HOST: postfix-mailcow        # Mailcow's Postfix container name
      MAIL_PORT: "587"
      MAIL_STARTTLS: REQUIRED
      MAIL_USER: notifications@yourdomain.com
      MAIL_PASSWORD: "${MAIL_PASSWORD}"  # from .env file
      MAIL_FROM: notifications@yourdomain.com
      EVOLUTION_API_URL: "${EVOLUTION_API_URL}"
      EVOLUTION_API_KEY: "${EVOLUTION_API_KEY}"
      EVOLUTION_API_INSTANCE: "${EVOLUTION_API_INSTANCE}"
      ADMIN_PROVISIONING_TOKEN: "${ADMIN_PROVISIONING_TOKEN}"
    ports:
      - "8080:8080"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - app-network
      - mailcow-network   # join Mailcow's network to reach postfix-mailcow

networks:
  app-network:
  mailcow-network:
    external: true      # created by Mailcow's own docker-compose

volumes:
  postgres_data:
```

Create a `.env` file at the same level (add to `.gitignore`):

```dotenv
MAIL_PASSWORD=changeme
EVOLUTION_API_URL=http://evolution-api:8081
EVOLUTION_API_KEY=changeme
EVOLUTION_API_INSTANCE=turtle
ADMIN_PROVISIONING_TOKEN=changeme
```

#### 5. Mailcow network name verification

The exact network name depends on Mailcow's `mailcow.conf` `COMPOSE_PROJECT_NAME` (default: `mailcowdockerized`). Verify with:

```bash
docker network ls | grep mailcow
```

Update `mailcow-network` → actual name if it differs (e.g., `mailcowdockerized_mailcow-network`).

### Success Criteria

#### Automated Verification

- [ ] `docker compose up -d` on the production server completes with no errors.
- [ ] `docker exec turtle-api-turtle-api-1 curl -s telnet://postfix-mailcow:587` responds (connectivity check).

#### Manual Verification

- [ ] Mailcow admin UI accessible at `https://mail.yourdomain.com`.
- [ ] Send test email from Mailcow UI → verify delivery to an external inbox.
- [ ] Trigger a booking from the app → check Mailcow **Logs → SMTP** for outbound delivery record.
- [ ] Check the recipient's inbox for the HTML email with correct subject and body.
- [ ] Run `./mvnw test` — no tests fail due to SMTP configuration changes (mock mode active in tests).

**Pause here for manual confirmation of email delivery end-to-end before considering the implementation complete.**

---

## Testing Strategy

### Unit Tests

- `EmailNotificationServiceTest` — uses `MockMailbox` (in-memory, no SMTP); asserts recipient, subject, and that null/blank email is guarded.
- Existing `NotificationServiceTest` — unchanged; WhatsApp path still tested independently.

### Integration / Manual Tests

1. `docker compose up -d` (dev mode with Mailpit).
2. `./mvnw quarkus:dev`.
3. Register CLIENT and COACH via `POST /auth/register`.
4. Coach adds availability slot.
5. Client books the slot.
6. Open `http://localhost:8025` — assert email arrived at coach's address with "New booking request" subject.
7. Coach approves via `PATCH /bookings/{id}/approve`.
8. Assert email arrived at client's address with "confirmed" subject.
9. Client sends a chat message.
10. Assert email arrived at coach's address with "New message from" subject.
11. Verify existing WhatsApp notifications still fire (check Evolution API / mock logs).

---

## Performance Considerations

- Email sending is synchronous in the CDI observer today. The Vert.x-backed `Mailer` performs the SMTP exchange on a worker thread so it doesn't block the event loop. For the current scale this is acceptable.
- If email volume grows or SMTP latency becomes a concern, switch to `ReactiveMailer` and fire-and-forget with `Uni.subscribe()` — this is a future concern.

---

## Migration Notes

- No database migrations required — `AppUser.email` already exists.
- No breaking changes to any existing API contract.
- The only change to existing source files is `BookingEventObserver.java` (Phase 3).

---

## References

- Quarkus Mailer guide: https://quarkus.io/guides/mailer
- Quarkus Mailer config reference: https://quarkus.io/guides/mailer-reference
- Mailpit Docker image: https://github.com/axllent/mailpit
- Mailcow installation: https://docs.mailcow.email/i_u_m/i_u_m_install/
- Mailcow DNS setup: https://docs.mailcow.email/prerequisite/prerequisite-dns/
- Mailcow DKIM: https://docs.mailcow.email/manual-guides/mailcow-UI/ui-dkim/
- Current WhatsApp notification implementation: `src/main/java/turtle/notification/NotificationService.java`
- Event observer: `src/main/java/turtle/notification/BookingEventObserver.java`
